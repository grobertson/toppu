#!/usr/bin/python
# coding=utf-8
"""
toppu - a small top-like utility for monitoring Heroku dyno response times
"""

import curses
import datetime
import optparse
import re
import shlex
import subprocess
import sys
from Controls import Gauge, HttpStatusGauge, Heading

banner = "\ntoppu - A top-like tool for Heroku: https://github.com/grobertson/toppu"
usage = "toppu -a <appname> [--solarized]" 

PARSER = optparse.OptionParser(usage=''.join([usage,banner]))

# app name
PARSER.add_option('-a', action="store", dest="app", help="heroku app name")
PARSER.add_option('--app', action="store", dest="app", help="heroku app name")

# for tinkering
PARSER.add_option('--devel', action="store_true", dest="debug", help="for tinkering with the parser.")

# timeout declaration, unused after refactor,
#TODO: thresholds
#PARSER.add_option('-t', action="store", dest="timeout", type="int", help="timeout in milliseconds.")
#PARSER.add_option('--timeout', action="store", dest="timeout", type="int", help="timeout in milliseconds.")
#PARSER.set_defaults(timeout=2000)

PARSER.add_option('--solarized', action="store_true", dest="solarized", help="easy on the eyes.")
PARSER.set_defaults(solarized=False)
OPTIONS, ARGS = PARSER.parse_args()


try:
    assert OPTIONS.app is not None
    APP_NAME = OPTIONS.app
    #assert OPTIONS.timeout is not None
    #TIMEOUT = OPTIONS.timeout
    TIMEOUT = 0
    assert OPTIONS.solarized is not None
    SOLARIZED = OPTIONS.solarized
except AssertionError:
    PARSER.error("No appname specified.")
    exit()


PARSE_ERRORS = []

class Toppu(object):
    ''' 
        This dedicated to my engineers that was down from day one.
        Welcome to the cli 
            ...like we always do about this time.
        
        Apologies to Dr. Dre
    '''
    def __init__(self):
        self.stream = LogStream(APP_NAME)
        self.logparser = LogParser()
        self.display = Display()
        self.dynos = {}
        try:
            self.run()
        except KeyboardInterrupt:
            del self.display
            print >> sys.stderr, "\nUnparseable log lines:\n"
            for err in PARSE_ERRORS:
                print >> sys.stderr, "{err}".format(err=err)
        except Exception:
            del self.display
            raise


    def run(self):
        for line in self.stream:
            data =  self.logparser.parse(line)
            if not data:
                continue

            if data['log_type'] == 'router':
                try:
                    assert data['dyno']
                    assert data['connect']
                    assert data['service']
                    assert data['status']
                except KeyError:
                    # continue to the next line if necessary data isn't present
                    continue

                # data present, keep moving
                (d_type, d_number) = data['dyno'].split('.')
                #We build an array of dicts representing each dyno we've seen so far.
                #If our dict already exists, the Controls.Gauge has been created, so we just update
                if self.dynos.__contains__(data['dyno']):
                    self.dynos[data['dyno']]['dyno'].update(data['dyno'])
                    self.dynos[data['dyno']]['connect'].update(int(data['connect'].replace('ms','')))
                    self.dynos[data['dyno']]['service'].update(int(data['service'].replace('ms','')))
                    self.dynos[data['dyno']]['status'].update(data['status'])
                else:
                    #if the dict didn't exist, add it and make a new Controls.Gauge 
                    self.dynos[data['dyno']] = {}
                    self.dynos[data['dyno']]['dyno'] = Gauge(   self.display.STDSCR, 
                                                                self.display.rowrange[int(d_number)], 
                                                                self.display.colrange[0], 
                                                                data['dyno'])
                    
                    self.dynos[data['dyno']]['connect'] = Gauge(self.display.STDSCR, 
                                                                self.display.rowrange[int(d_number)], 
                                                                self.display.colrange[1], 
                                                                int(data['connect'].replace('ms','')), 
                                                                units='ms',
                                                                highlight_minmax=True)
                    
                    self.dynos[data['dyno']]['service'] = Gauge(self.display.STDSCR, 
                                                                self.display.rowrange[int(d_number)], 
                                                                self.display.colrange[2], 
                                                                int(data['service'].replace('ms','')), 
                                                                units='ms',
                                                                highlight_minmax=True)
                    
                    self.dynos[data['dyno']]['status'] = Gauge( self.display.STDSCR, 
                                                                self.display.rowrange[int(d_number)], 
                                                                self.display.colrange[3], 
                                                                data['status'])
                    self.dynos[data['dyno']]['dyno'].draw()
                    self.dynos[data['dyno']]['connect'].draw()
                    self.dynos[data['dyno']]['service'].draw()
                    self.dynos[data['dyno']]['status'].draw()


            elif data['log_type'] == 'web':
                continue
            elif data['log_type'] == 'worker':
                continue
        
            c = self.display.STDSCR.getch()
            if not c == -1:
                if c == ord('q'):
                    exit()
        
        
class LogStream(object):

    def __init__(self, app_name):
        self.app_name = app_name
        return None
        
    def __iter__(self):
        """Runs the `heroku logs` command with the appropriate app name and wraps it 
            up nicely in a familiar iterable object.
        """
        command = '/usr/bin/heroku logs -t --app ' + self.app_name
        args = shlex.split(command)
        heroku = subprocess.Popen(args,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        return iter(heroku.stdout.readline, b'')
    
    

class LogParser(object):
    ''' Let's read some loglines, shall we? '''
    def __init__(self):
        # 
        return None

    def parse(self, line):
        """Tries to parse a single Heroku logline"""
        line = re.sub('\n', '', line)
        line_halves = re.split('\]\: ', line)
        line_meta = re.split(' ', line_halves[0])

        parsed_data = dict()
        parsed_data['timestamp'] = line_meta[0]
        if line_meta.__len__() > 1:
            try:
                parsed_type = re.search('^([a-zA-Z]+)\[([a-zA-Z]+)', line_meta[1])
                parsed_data['log_source'] = parsed_type.group(1)
                parsed_data['log_type'] = parsed_type.group(2)
                parsed_time = re.match(
                    '([\d][\d][\d][\d])\-([\d][\d])\-([\d][\d])T([\d][\d])\:([\d][\d])\:([\d][\d])',
                    parsed_data['timestamp'])
                year_int = int(parsed_time.group(1))
                month_int = int(parsed_time.group(2))
                day_int = int(parsed_time.group(3))
                hour_int = int(parsed_time.group(4))
                minute_int = int(parsed_time.group(5))
                second_int = int(parsed_time.group(6))
                parsed_data['log_time'] = datetime.datetime(
                    year_int, month_int, day_int, hour_int, minute_int, second_int)
            except AttributeError:
                PARSE_ERRORS.append(line)
                return False
        else:
            return False

        if parsed_data['log_source'] == "heroku":
            if line_halves.__len__() > 1:
                line_halves[1] = re.sub(', ', ',', line_halves[1])
                line_chunks = re.split(' ', line_halves[1])
                for chunk in line_chunks:
                    line_chunks = re.split('=', chunk)
                    if line_chunks.__len__() > 2:
                        #fwd and path are a little clunky to parse
                        pass
                    elif line_chunks.__len__() > 1:
                        parsed_data[line_chunks[0]] = line_chunks[1]
                    else:
                        pass
            else:
                return False
        else:
            # app (i.e. app[instance] or (async job output) app.*.*[guid] lines
            # would need specific parsing and you'd do that somewhere around here
            return False

        return parsed_data


class Display(object):
    ''' Big thanks to https://github.com/mooseman/pd_curses_stuff/ '''
    def __init__(self):
        self.STDSCR = curses.initscr()
        curses.start_color()
        curses.noecho()
        curses.cbreak()
        self.STDSCR.nodelay(1)
        self.STDSCR.keypad(1)
        self.STDSCR.scrollok(1)
        self.STDSCR.idlok(1)      
        self.STDSCR.leaveok(0)
        
        self.palette()
        
        # The boundaries of the screen 
        (y, x) = self.STDSCR.getmaxyx() 
        self.maxrows = y  
        self.maxcols = x
        
        #scroll port
        #self.STDSCR.setscrreg(6, self.maxrows-2)
        
        #every row is a display row.
        self.rowrange = list(range(5, self.maxrows-2))  

        columns = 4
        # leading spaces, width of screen, width of a column
        self.colrange = list(range( 1 , self.maxcols, self.maxcols / columns ) ) 

        self.colheadposlist = list( (y,x) 
            for y in range(5, 6) 
                for x in self.colrange )
                        
        # Draw the headings
        bar = ""
        for i in range(1, self.maxcols):
            bar = bar + " "
        self.STDSCR.addstr(5, 1, bar, curses.A_REVERSE) 
        self.coldata = ["Dyno", "Connect", "Service","Status"]
        self.ch = Heading(self.colheadposlist, self.coldata, column_padding=4)  
        for label, pos in zip(self.coldata, self.colheadposlist):
            self.STDSCR.addstr(pos[0], pos[1], label, curses.A_REVERSE)
        self.STDSCR.refresh()
        return None

    def __del__(self):
        curses.nocbreak()
        self.STDSCR1.keypad(0)
        curses.echo()
        curses.endwin()

    def palette(self):
        for col in range(1,255):
            curses.init_pair(col, col, 0)
            #pass
        #curses.init_pair(7, 7, 0)
        #curses.init_pair(3, 3, 0)
        #curses.init_pair(4, 4, 0)
        

if __name__ == "__main__":
    t = Toppu()
