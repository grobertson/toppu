#!/usr/bin/python
"""
toppu - a small top-like utility for monitoring Heroku dyno response times
"""

import curses
import datetime
import optparse
import re
import shlex
import subprocess
import sys

PARSER = optparse.OptionParser()

# handle app declaration
PARSER.add_option('-a', action="store", dest="app")
PARSER.add_option('--app', action="store", dest="app")

# handle timeout declaration
PARSER.add_option('-t', action="store", dest="timeout", type="int")
PARSER.add_option('--timeout', action="store", dest="timeout", type="int")
PARSER.set_defaults(timeout=2000)

OPTIONS, ARGS = PARSER.parse_args()

try:
    assert OPTIONS.app is not None
    APP_NAME = OPTIONS.app
    assert OPTIONS.timeout is not None
    TIMEOUT = OPTIONS.timeout
except AssertionError:
    print "toppu - Top-like command line performance monitoring for Heroku"
    print "https://github.com/grobertson/toppu"
    print
    print "Usage: toppu -a <appname> [-t <timeout in ms>]"
    exit()


STDSCR = curses.initscr()
curses.start_color()
curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_WHITE, curses.COLOR_BLACK)
curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_BLACK)

PARSE_ERRORS = []

def parse_line(line):
    """Tries to intellingently parse a single Heroku logline"""

    line = clean_logline(line)
    line_halves = re.split('\]\: ', line)
    line_meta = re.split(' ', line_halves[0])

    parsed_data = dict()
    parsed_data['timestamp'] = line_meta[0]
    if line_meta.__len__() > 1:
        try:
            parsed_type = re.search('^([a-zA-Z]+)\[([a-zA-Z]+)', line_meta[1])
            parsed_data['log_source'] = parsed_type.group(1)
            parsed_data['log_type'] = parsed_type.group(2)
            parsed_time = re.match(
                '([\d][\d][\d][\d])\-([\d][\d])\-([\d][\d])T([\d][\d])\:([\d][\d])\:([\d][\d])',
                parsed_data['timestamp'])
            year_int = int(parsed_time.group(1))
            month_int = int(parsed_time.group(2))
            day_int = int(parsed_time.group(3))
            hour_int = int(parsed_time.group(4))
            minute_int = int(parsed_time.group(5))
            second_int = int(parsed_time.group(6))
            parsed_data['log_time'] = datetime.datetime(
                year_int, month_int, day_int, hour_int, minute_int, second_int)
        except AttributeError:
            PARSE_ERRORS.append(line)
            return False
    else:
        return False

    if parsed_data['log_source'] == "heroku":
        if line_halves.__len__() > 1:
            line_halves[1] = re.sub(', ', ',', line_halves[1])
            line_chunks = re.split(' ', line_halves[1])
            for chunk in line_chunks:
                line_chunks = re.split('=', chunk)
                if line_chunks.__len__() > 2:
                    #fwd and path are a little clunky to parse
                    pass
                elif line_chunks.__len__() > 1:
                    parsed_data[line_chunks[0]] = line_chunks[1]
                else:
                    pass
        else:
            return False
    else:
        # app (i.e. app[instance] or (async job output) app.*.*[guid] lines
        # would need specific parsing and you'd do that somewhere around here
        return False

    return parsed_data


def run_heroku(app_name):
    """Runs the `heroku logs` command with the appropriate app name"""

    command = '/usr/bin/heroku logs -t --app ' + app_name
    args = shlex.split(command)
    heroku = subprocess.Popen(args,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    return iter(heroku.stdout.readline, b'')


def clean_logline(line):
    line = re.sub('\n', '', line)
    return line

def make_line(dyno, connect, service, status, **extra):
    """Constructs log lines for curses output"""
    return "{dyno}\t\t{connect}\t\t{service}\t\t{status}".format(
        dyno=dyno,
        connect=connect,
        service=service,
        status=status,
    )

def add_line(line_number, data, color):
    """Adds a line of text to and refreshes the curses terminal"""
    STDSCR.addstr(line_number, 1, make_line(**data), curses.color_pair(color))
    STDSCR.refresh()


def main():
    """Main run loop of toppu"""
    STDSCR.addstr(0, 1, "Dyno\t\tConnect\t\tService\t\tStatus", curses.A_REVERSE)

    try:

        for line in run_heroku(APP_NAME):
            data =  parse_line(line)
            if not data:
                continue

            if data['log_type'] == 'router':
                try:
                    assert data['dyno']
                    assert data['connect']
                    assert data['service']
                    assert data['status']
                except KeyError:
                    # continue to the next line if necessary data isn't present
                    continue

                # data present, keep moving
                line_number = int(re.search('\.([\d]+)', data['dyno']).group(1))
                if data['status'] == "503":
                    add_line(line_number, data, 1)
                    continue

                # not a 503, see if this exceeds the timeout
                service = re.search('([\d]+)ms', data['service'])
                service_time = int(service.group(1))
                if service_time < TIMEOUT:
                    color = 3
                else:
                    color = 2

                add_line(line_number, data, color)

            elif data['log_type'] == 'web':
                continue
            elif data['log_type'] == 'worker':
                continue

    except KeyboardInterrupt:
        curses.endwin()
        print >> sys.stderr, "\nUnparseable log lines:\n"
        for err in PARSE_ERRORS:
            print >> sys.stderr, "{err}".format(err=err)
    except Exception:
        curses.endwin()
        raise

if __name__ == "__main__":
    main()
