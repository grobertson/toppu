#!/usr/bin/python
"""
toppu - a small top-like utility for monitoring Heroku dyno response times
"""

import curses
import datetime
import optparse
import re
import shlex
import subprocess
import sys
from Controls import Gauge, Heading

PARSER = optparse.OptionParser()

# handle app declaration
PARSER.add_option('-a', action="store", dest="app")
PARSER.add_option('--app', action="store", dest="app")

# handle timeout declaration
PARSER.add_option('-t', action="store", dest="timeout", type="int")
PARSER.add_option('--timeout', action="store", dest="timeout", type="int")
PARSER.set_defaults(timeout=2000)

OPTIONS, ARGS = PARSER.parse_args()

try:
    assert OPTIONS.app is not None
    APP_NAME = OPTIONS.app
    assert OPTIONS.timeout is not None
    TIMEOUT = OPTIONS.timeout
except AssertionError:
    print "toppu - Top-like command line performance monitoring for Heroku"
    print "https://github.com/grobertson/toppu"
    print
    print "Usage: toppu -a <appname> [-t <timeout in ms>]"
    exit()


PARSE_ERRORS = []

class Toppu(object):
    ''' This is for my programmers that was down with the cli since day one.'''
    def __init__(self):
        self.stream = LogStream(APP_NAME)
        self.logparser = LogParser()
        self.display = Display()
        self.dynos = {}
        try:
            self.run()
        except KeyboardInterrupt:
            del self.display
            print >> sys.stderr, "\nUnparseable log lines:\n"
            for err in PARSE_ERRORS:
                print >> sys.stderr, "{err}".format(err=err)
        except Exception:
            del self.display
            raise


    def run(self):
        for line in self.stream:
            data =  self.logparser.parse(line)
            if not data:
                continue

            if data['log_type'] == 'router':
                try:
                    assert data['dyno']
                    assert data['connect']
                    assert data['service']
                    assert data['status']
                except KeyError:
                    # continue to the next line if necessary data isn't present
                    continue

                # data present, keep moving
                (d_type, d_number) = data['dyno'].split('.')
                #We build an array of dicts representing each dyno we've seen so far.
                #If our dict already exists, the Controls.Gauge has been created, so we just update
                if self.dynos.__contains__(data['dyno']):
                    self.dynos[data['dyno']]['dyno'].update(data['dyno'])
                    self.dynos[data['dyno']]['connect'].update(int(data['connect'].replace('ms','')))
                    self.dynos[data['dyno']]['service'].update(int(data['service'].replace('ms','')))
                    self.dynos[data['dyno']]['status'].update(data['status'])
                else:
                    #if the dict didn't exist, add it and make a new Controls.Gauge 
                    self.dynos[data['dyno']] = {}
                    self.dynos[data['dyno']]['dyno'] = Gauge(self.display.STDSCR, self.display.rowrange[int(d_number)], self.display.colrange[0], data['dyno'])
                    self.dynos[data['dyno']]['connect'] = Gauge(self.display.STDSCR, self.display.rowrange[int(d_number)], self.display.colrange[2], int(data['connect'].replace('ms','')), units='ms')
                    self.dynos[data['dyno']]['service'] = Gauge(self.display.STDSCR, self.display.rowrange[int(d_number)], self.display.colrange[4], int(data['service'].replace('ms','')), units='ms')
                    self.dynos[data['dyno']]['status'] = Gauge(self.display.STDSCR, self.display.rowrange[int(d_number)], self.display.colrange[6], data['status'])
                    self.dynos[data['dyno']]['dyno'].draw()
                    self.dynos[data['dyno']]['connect'].draw()
                    self.dynos[data['dyno']]['service'].draw()
                    self.dynos[data['dyno']]['status'].draw()


            elif data['log_type'] == 'web':
                continue
            elif data['log_type'] == 'worker':
                continue

        
        
class LogStream(object):

    def __init__(self, app_name):
        self.app_name = app_name
        return None
        
    def __iter__(self):
        """Runs the `heroku logs` command with the appropriate app name and wraps it 
            up nicely in a familiar iterable object.
        """
        command = '/usr/bin/heroku logs -t --app ' + self.app_name
        args = shlex.split(command)
        heroku = subprocess.Popen(args,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        return iter(heroku.stdout.readline, b'')
    
    

class LogParser(object):
    ''' Let's read some loglines, shall we? '''
    def __init__(self):
        # 
        return None

    def parse(self, line):
        """Tries to intellingently parse a single Heroku logline"""
        line = re.sub('\n', '', line)
        line_halves = re.split('\]\: ', line)
        line_meta = re.split(' ', line_halves[0])

        parsed_data = dict()
        parsed_data['timestamp'] = line_meta[0]
        if line_meta.__len__() > 1:
            try:
                parsed_type = re.search('^([a-zA-Z]+)\[([a-zA-Z]+)', line_meta[1])
                parsed_data['log_source'] = parsed_type.group(1)
                parsed_data['log_type'] = parsed_type.group(2)
                parsed_time = re.match(
                    '([\d][\d][\d][\d])\-([\d][\d])\-([\d][\d])T([\d][\d])\:([\d][\d])\:([\d][\d])',
                    parsed_data['timestamp'])
                year_int = int(parsed_time.group(1))
                month_int = int(parsed_time.group(2))
                day_int = int(parsed_time.group(3))
                hour_int = int(parsed_time.group(4))
                minute_int = int(parsed_time.group(5))
                second_int = int(parsed_time.group(6))
                parsed_data['log_time'] = datetime.datetime(
                    year_int, month_int, day_int, hour_int, minute_int, second_int)
            except AttributeError:
                PARSE_ERRORS.append(line)
                return False
        else:
            return False

        if parsed_data['log_source'] == "heroku":
            if line_halves.__len__() > 1:
                line_halves[1] = re.sub(', ', ',', line_halves[1])
                line_chunks = re.split(' ', line_halves[1])
                for chunk in line_chunks:
                    line_chunks = re.split('=', chunk)
                    if line_chunks.__len__() > 2:
                        #fwd and path are a little clunky to parse
                        pass
                    elif line_chunks.__len__() > 1:
                        parsed_data[line_chunks[0]] = line_chunks[1]
                    else:
                        pass
            else:
                return False
        else:
            # app (i.e. app[instance] or (async job output) app.*.*[guid] lines
            # would need specific parsing and you'd do that somewhere around here
            return False

        return parsed_data


class Display(object):
    ''' Big thanks to https://github.com/mooseman/pd_curses_stuff/ '''
    def __init__(self):
        self.STDSCR = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.STDSCR.keypad(1)
        self.STDSCR.scrollok(1)
        self.STDSCR.idlok(1)      
        self.STDSCR.leaveok(0)
        curses.start_color()
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_BLUE, curses.COLOR_BLACK)
        curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
        
        # The boundaries of the screen 
        (y, x) = self.STDSCR.getmaxyx() 
        self.maxrows = y  
        self.maxcols = x
        
        #scroll port
        #self.STDSCR.setscrreg(6, self.maxrows-2)
        
        #every row is a display row.
        self.rowrange = list(range(6, self.maxrows-2))  

        columns = 8
        # leading spaces, width of screen, width of a column ( 2 * offset = space on center)
        self.colrange = list(range( 1 , self.maxcols, self.maxcols / (columns * 2) ) ) 

        self.colheadposlist = list( (y,x) 
            for y in range(5, 6) 
                for x in self.colrange )
                        
        # Draw the headings 
        self.coldata = [" Dyno ", '', " Connect ", '', " Service ", ''," Status ", '']
        self.ch = Heading(self.colheadposlist, self.coldata)  
        for label, pos in zip(self.coldata, self.colheadposlist):
            self.STDSCR.addstr(pos[0], pos[1], label, curses.A_REVERSE)
        return None

    def __del__(self):
        curses.nocbreak()
        stdscr.keypad(0)
        curses.echo()
        curses.endwin()


if __name__ == "__main__":
    t = Toppu()
